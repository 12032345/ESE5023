PS1_1
按照流程图写出程序，使得a，b，c按照从大到小排列。
PS1_2
创建两个矩阵M1，M2，分别填入50个随机数，其中随机数使用到了sample函数。将M1和M2按照矩阵乘法逐行逐列相乘得M3，最后用R语言中得矩阵乘法M4 <- M1%*%M2来检验。
打印M3和M4，发现结果相同。
PS1_3
开始使用的是for循环，按照帕斯卡三角形了得每个数都是上一行左右两个数相加逐行打印；
后来发现帕斯卡三角形中得每一行数符合二项分布数列，即用choose（)函数打印出每一行，再用lappy（）函数循环每一行，使程序更为简洁。
PS1_4
使用倒推法：创建一个向量v来记录从v[i]到1的步数
因为只有+1和*2两种方式才能到达i，故对于每一个i，v[i]都比v[i-1]多1，当i能整除2时，v则取v[i]和v[i/2]+1的最小值
PS1_5
创建一个向量nums来记录9个数，题目要求为在9个数之间插入+或-或空（即合并两个数）使得等式结果为x。一共又3^8种可能。
遍历这3^8种可能：用buffer记录表达式，用result记录表达式的结果。temp记录当前计算到的数字。
遍历9个数之间的8个空隙，每个空有三种可能，分别进行相应的计算，记录结果result。
当result == x时，打印出该表达式，并将totol_solution的数+1。
最后plot出100个数和其对应的totol_solution，发现88的totol_solution最少，1和45的totol_solution最多。
PS1_6
